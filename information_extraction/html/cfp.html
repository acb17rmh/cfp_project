<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>cfp API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cfp</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import dateparser
import re

class Cfp:

    &#34;&#34;&#34;
    Class representing a Call for Paper (CFP) object. Each CFP object contains attributes corresponding to its labels
    in the dataset, as well as a field containing the CFP&#39;s text.
    &#34;&#34;&#34;
    def __init__(self, name=&#34;DEFAULT NAME&#34;, start_date=&#34;01/01/1970&#34;, end_date=&#34;02/01/1970&#34;,
                 location=&#34;Lowestoft&#34;, submission_deadline=&#34;31/12/1969&#34;, notification_due=&#34;31/12/1969&#34;,
                 final_version_deadline=&#34;31/12/1969&#34;, cfp_text=&#34;DEFAULT CFP_TEXT&#34;, url=&#34;https://google.com&#34;):
        &#34;&#34;&#34;
        Constructs a CFP object.

        Attributes:
            name: The conference&#39;s name as a string.
            start_date: The conference&#39;s start date, as a string in DD/MM/YYYY format.
            end_date: The conferenece&#39;s end date, as a string in DD/MM/YYYY format.
            location: The place the conference is being held, as a string.
            submission_deadline: The date of the conference&#39;s submission deadline, as a string in DD/MM/YYYY format.
            notification_due: The notification due date of the conference, as a string in DD/MM/YYYY format.
            final_version_deadline: The conference&#39;s final version deadline, as a string in DD/MM/YYYY format.
            cfp_text: The CFP&#39;s body text.
            url: The web address of the conference.
        &#34;&#34;&#34;

        self.name = name
        self.start_date = start_date
        self.end_date = end_date
        self.location = location
        self.submission_deadline = submission_deadline
        self.notification_due = notification_due
        self.final_version_deadline = final_version_deadline
        self.cfp_text = cfp_text
        self.url = url

    def __str__(self):
        &#34;&#34;&#34;
        Function to better display the attributes of a CFP when printed.
        Overrides the build in __str__ method.
        &#34;&#34;&#34;
        return &#34;NAME: {} START: {} END: {} LOCATION: {} \n SUBMISSION DEADLINE: {} &#34; \
               &#34;NOTIFICATION DUE: {} FINAL VERSION DEADLINE: {} URL: {}&#34;.format(self.name, self.start_date, self.end_date,
                                                                        self.location, self.submission_deadline,
                                                                        self.notification_due,
                                                                        self.final_version_deadline, self.url)


    def as_dict(self):
        &#34;&#34;&#34;
        Returns the CFP object as a dictionary.
        Returns:
            dict: A dictionary representing the CFP object.
        &#34;&#34;&#34;
        return {&#39;name&#39;: self.name,
                &#39;start_date&#39;: self.start_date,
                &#39;end_date&#39;: self.end_date,
                &#39;location&#39;: self.location,
                &#39;submission_deadline&#39;: self.submission_deadline,
                &#39;notification_due&#39;: self.notification_due,
                &#39;final_version_deadline&#39;: self.final_version_deadline,
                &#39;url&#39;: self.url}


    def extract_locations(self, nlp):
        &#34;&#34;&#34;
        Extracts all locations mentioned in the CFP&#39;s text.

        Args:
            nlp: An instance of a Spacy NLP object.
        Returns:
            list: A list of all locations mentioned in the CFP&#39;s text.
        &#34;&#34;&#34;
        doc = nlp(self.cfp_text)

        # Initialise lists for the locations within a given CFP
        cfp_locations = []

        for entity in doc.ents:
            if entity.label_ == &#34;GPE&#34;:
                cfp_locations.append(entity.text)

        return cfp_locations

    def extract_dates(self, nlp):
        &#34;&#34;&#34;
        Function which extracts mentions of dates from the CFP&#39;s text.

        Args:
            nlp: An instance of a Spacy NLP object.
        Returns:
            dict: A dictionary of form {date -&gt; sentence containing that date}.
        &#34;&#34;&#34;
        # a dictionary mapping a date to the sentence it is in
        date_to_sentence = {}
        # returns a list of sentences, split on line breaks.
        split_cfp_text = self.cfp_text.splitlines()

        for sent in split_cfp_text:
            doc = nlp(sent)

            # for each sentence in the cfp, NER tag it.
            # if there is a data in the sentence, store the data and the sentence it is contained in,
            # and map date -&gt; sentence.

            for entity in doc.ents:
                if entity.label_ == &#34;DATE&#34; and len(entity.text) &gt;= 10:
                    date = entity.text
                    date_to_sentence[date] = sent

        # removes any dates that cannot be parsed, i.e are incomplete, and makes sentence lowercase for next step
        date_to_sentence = {date: sent.lower() for date, sent in date_to_sentence.items() if
                            dateparser.parse(date) is not None}
        # returns a dictionary of form (date -&gt; sentence)
        return date_to_sentence



    # TODO: improve conference name extraction
    def extract_conference_name(self, conference_name_regex=re.compile(&#39;$^&#39;), ordinal_regex=re.compile(&#39;$^&#39;),
                                conjunction_regex=re.compile(&#39;$^&#39;), url_regex=re.compile(&#39;$^&#39;)):

        &#34;&#34;&#34;
        Function to extract the conference name from a CFP text. Uses rule-based patterns to assign scores to substrings
        of the CFP&#39;s text, and returns the one with the highest score. Takes regex patterns containing key words to filter
        by as parameters. By default, these regexes will match any string.

        Args:
            conference_name_regex: a regular expression matching key terms in a conference&#39;s name.
                                   By default, it will match any string.
            ordinal_regex: a regular expression matching ordinal numbers in a conference&#39;s name.
                           By default, it will match any string.
            conjunction_name_regex: a regular expression matching terms signifying a conference is a joint conference.
                                    By default, it will match any string.
            url_regex: a regular expression matching URLs. By default, it will match any string.

        Returns:
            str: The highest ranking string in the text.
        &#34;&#34;&#34;
        # a dictionary of form (sentence -&gt; score)
        candidate_names = {}
        split_cfp_text = self.preprocess_text()
        counter = 0

        for sent in split_cfp_text:
            score = 0
            if len(sent.split()) &lt; 4 or len(sent.split()) &gt; 20:
                score -= 50
            if counter &lt; 5:
                counter += 10 - (2 * counter)
            for word in sent.split():
                if conference_name_regex.search(word):
                    score += 8
                if ordinal_regex.search(word) and counter &lt; 10:
                    score += 10
                if conjunction_regex.search(word):
                    score -= 5
                if url_regex.search(word):
                    score -= 5

            candidate_names[sent] = score
            counter += 1

        print(candidate_names)
        # return the sentence with the highest score
        highest_score = (max(candidate_names, key=candidate_names.get))
        return highest_score


    def extract_urls(self, web_url_regex=re.compile(&#39;$^&#39;)):
        &#34;&#34;&#34;
        Method to extract any URLs from a CFP&#39;s text.

        Args:
            web_url_regex: a regular expression matching URLs. By default, it will match any string.
        Returns:
            list: A list of all mentions of URLs in the CFP&#39;s text.
        &#34;&#34;&#34;
        urls = []
        split_cfp_text = self.preprocess_text()
        for sent in split_cfp_text:
            if web_url_regex.search(sent):
                urls.append(web_url_regex.search(sent).group(0))
        return urls


    def preprocess_text(self):
        &#34;&#34;&#34;
        Method to preprocess text for information extraction. Text is split on newlines and commas,
        and any conference names split over 2 lines are merged into one.

        Returns:
            list: a list of preprocessed sentences.
        &#34;&#34;&#34;
        text = self.cfp_text.replace(&#34;\n&#34;, &#34;,&#34;)
        split_text = text.split(&#34;,&#34;)
        split_text = [sent for sent in split_text if sent is not &#34;&#34;]
        for index, sent in enumerate(split_text):
            if sent == &#34;&#34;:
                split_text.remove(sent)
            if &#34;  &#34; in sent:
                split_text.remove(sent)
            if sent.endswith(&#34; on&#34;) and (&#34;conference&#34; in sent.lower() or &#34;workshop&#34; in sent.lower() or
                                         &#34;international&#34; in sent.lower() or &#34;symposium&#34; in sent.lower()):
                full_name = (split_text[index] + &#34; &#34; + split_text[index + 1])
                return [full_name] + split_text
        return split_text</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cfp.Cfp"><code class="flex name class">
<span>class <span class="ident">Cfp</span></span>
<span>(</span><span>name='DEFAULT NAME', start_date='01/01/1970', end_date='02/01/1970', location='Lowestoft', submission_deadline='31/12/1969', notification_due='31/12/1969', final_version_deadline='31/12/1969', cfp_text='DEFAULT CFP_TEXT', url='https://google.com')</span>
</code></dt>
<dd>
<section class="desc"><p>Class representing a Call for Paper (CFP) object. Each CFP object contains attributes corresponding to its labels
in the dataset, as well as a field containing the CFP's text.</p>
<p>Constructs a CFP object.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The conference's name as a string.</dd>
<dt><strong><code>start_date</code></strong></dt>
<dd>The conference's start date, as a string in DD/MM/YYYY format.</dd>
<dt><strong><code>end_date</code></strong></dt>
<dd>The conferenece's end date, as a string in DD/MM/YYYY format.</dd>
<dt><strong><code>location</code></strong></dt>
<dd>The place the conference is being held, as a string.</dd>
<dt><strong><code>submission_deadline</code></strong></dt>
<dd>The date of the conference's submission deadline, as a string in DD/MM/YYYY format.</dd>
<dt><strong><code>notification_due</code></strong></dt>
<dd>The notification due date of the conference, as a string in DD/MM/YYYY format.</dd>
<dt><strong><code>final_version_deadline</code></strong></dt>
<dd>The conference's final version deadline, as a string in DD/MM/YYYY format.</dd>
<dt><strong><code>cfp_text</code></strong></dt>
<dd>The CFP's body text.</dd>
<dt><strong><code>url</code></strong></dt>
<dd>The web address of the conference.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cfp:

    &#34;&#34;&#34;
    Class representing a Call for Paper (CFP) object. Each CFP object contains attributes corresponding to its labels
    in the dataset, as well as a field containing the CFP&#39;s text.
    &#34;&#34;&#34;
    def __init__(self, name=&#34;DEFAULT NAME&#34;, start_date=&#34;01/01/1970&#34;, end_date=&#34;02/01/1970&#34;,
                 location=&#34;Lowestoft&#34;, submission_deadline=&#34;31/12/1969&#34;, notification_due=&#34;31/12/1969&#34;,
                 final_version_deadline=&#34;31/12/1969&#34;, cfp_text=&#34;DEFAULT CFP_TEXT&#34;, url=&#34;https://google.com&#34;):
        &#34;&#34;&#34;
        Constructs a CFP object.

        Attributes:
            name: The conference&#39;s name as a string.
            start_date: The conference&#39;s start date, as a string in DD/MM/YYYY format.
            end_date: The conferenece&#39;s end date, as a string in DD/MM/YYYY format.
            location: The place the conference is being held, as a string.
            submission_deadline: The date of the conference&#39;s submission deadline, as a string in DD/MM/YYYY format.
            notification_due: The notification due date of the conference, as a string in DD/MM/YYYY format.
            final_version_deadline: The conference&#39;s final version deadline, as a string in DD/MM/YYYY format.
            cfp_text: The CFP&#39;s body text.
            url: The web address of the conference.
        &#34;&#34;&#34;

        self.name = name
        self.start_date = start_date
        self.end_date = end_date
        self.location = location
        self.submission_deadline = submission_deadline
        self.notification_due = notification_due
        self.final_version_deadline = final_version_deadline
        self.cfp_text = cfp_text
        self.url = url

    def __str__(self):
        &#34;&#34;&#34;
        Function to better display the attributes of a CFP when printed.
        Overrides the build in __str__ method.
        &#34;&#34;&#34;
        return &#34;NAME: {} START: {} END: {} LOCATION: {} \n SUBMISSION DEADLINE: {} &#34; \
               &#34;NOTIFICATION DUE: {} FINAL VERSION DEADLINE: {} URL: {}&#34;.format(self.name, self.start_date, self.end_date,
                                                                        self.location, self.submission_deadline,
                                                                        self.notification_due,
                                                                        self.final_version_deadline, self.url)


    def as_dict(self):
        &#34;&#34;&#34;
        Returns the CFP object as a dictionary.
        Returns:
            dict: A dictionary representing the CFP object.
        &#34;&#34;&#34;
        return {&#39;name&#39;: self.name,
                &#39;start_date&#39;: self.start_date,
                &#39;end_date&#39;: self.end_date,
                &#39;location&#39;: self.location,
                &#39;submission_deadline&#39;: self.submission_deadline,
                &#39;notification_due&#39;: self.notification_due,
                &#39;final_version_deadline&#39;: self.final_version_deadline,
                &#39;url&#39;: self.url}


    def extract_locations(self, nlp):
        &#34;&#34;&#34;
        Extracts all locations mentioned in the CFP&#39;s text.

        Args:
            nlp: An instance of a Spacy NLP object.
        Returns:
            list: A list of all locations mentioned in the CFP&#39;s text.
        &#34;&#34;&#34;
        doc = nlp(self.cfp_text)

        # Initialise lists for the locations within a given CFP
        cfp_locations = []

        for entity in doc.ents:
            if entity.label_ == &#34;GPE&#34;:
                cfp_locations.append(entity.text)

        return cfp_locations

    def extract_dates(self, nlp):
        &#34;&#34;&#34;
        Function which extracts mentions of dates from the CFP&#39;s text.

        Args:
            nlp: An instance of a Spacy NLP object.
        Returns:
            dict: A dictionary of form {date -&gt; sentence containing that date}.
        &#34;&#34;&#34;
        # a dictionary mapping a date to the sentence it is in
        date_to_sentence = {}
        # returns a list of sentences, split on line breaks.
        split_cfp_text = self.cfp_text.splitlines()

        for sent in split_cfp_text:
            doc = nlp(sent)

            # for each sentence in the cfp, NER tag it.
            # if there is a data in the sentence, store the data and the sentence it is contained in,
            # and map date -&gt; sentence.

            for entity in doc.ents:
                if entity.label_ == &#34;DATE&#34; and len(entity.text) &gt;= 10:
                    date = entity.text
                    date_to_sentence[date] = sent

        # removes any dates that cannot be parsed, i.e are incomplete, and makes sentence lowercase for next step
        date_to_sentence = {date: sent.lower() for date, sent in date_to_sentence.items() if
                            dateparser.parse(date) is not None}
        # returns a dictionary of form (date -&gt; sentence)
        return date_to_sentence



    # TODO: improve conference name extraction
    def extract_conference_name(self, conference_name_regex=re.compile(&#39;$^&#39;), ordinal_regex=re.compile(&#39;$^&#39;),
                                conjunction_regex=re.compile(&#39;$^&#39;), url_regex=re.compile(&#39;$^&#39;)):

        &#34;&#34;&#34;
        Function to extract the conference name from a CFP text. Uses rule-based patterns to assign scores to substrings
        of the CFP&#39;s text, and returns the one with the highest score. Takes regex patterns containing key words to filter
        by as parameters. By default, these regexes will match any string.

        Args:
            conference_name_regex: a regular expression matching key terms in a conference&#39;s name.
                                   By default, it will match any string.
            ordinal_regex: a regular expression matching ordinal numbers in a conference&#39;s name.
                           By default, it will match any string.
            conjunction_name_regex: a regular expression matching terms signifying a conference is a joint conference.
                                    By default, it will match any string.
            url_regex: a regular expression matching URLs. By default, it will match any string.

        Returns:
            str: The highest ranking string in the text.
        &#34;&#34;&#34;
        # a dictionary of form (sentence -&gt; score)
        candidate_names = {}
        split_cfp_text = self.preprocess_text()
        counter = 0

        for sent in split_cfp_text:
            score = 0
            if len(sent.split()) &lt; 4 or len(sent.split()) &gt; 20:
                score -= 50
            if counter &lt; 5:
                counter += 10 - (2 * counter)
            for word in sent.split():
                if conference_name_regex.search(word):
                    score += 8
                if ordinal_regex.search(word) and counter &lt; 10:
                    score += 10
                if conjunction_regex.search(word):
                    score -= 5
                if url_regex.search(word):
                    score -= 5

            candidate_names[sent] = score
            counter += 1

        print(candidate_names)
        # return the sentence with the highest score
        highest_score = (max(candidate_names, key=candidate_names.get))
        return highest_score


    def extract_urls(self, web_url_regex=re.compile(&#39;$^&#39;)):
        &#34;&#34;&#34;
        Method to extract any URLs from a CFP&#39;s text.

        Args:
            web_url_regex: a regular expression matching URLs. By default, it will match any string.
        Returns:
            list: A list of all mentions of URLs in the CFP&#39;s text.
        &#34;&#34;&#34;
        urls = []
        split_cfp_text = self.preprocess_text()
        for sent in split_cfp_text:
            if web_url_regex.search(sent):
                urls.append(web_url_regex.search(sent).group(0))
        return urls


    def preprocess_text(self):
        &#34;&#34;&#34;
        Method to preprocess text for information extraction. Text is split on newlines and commas,
        and any conference names split over 2 lines are merged into one.

        Returns:
            list: a list of preprocessed sentences.
        &#34;&#34;&#34;
        text = self.cfp_text.replace(&#34;\n&#34;, &#34;,&#34;)
        split_text = text.split(&#34;,&#34;)
        split_text = [sent for sent in split_text if sent is not &#34;&#34;]
        for index, sent in enumerate(split_text):
            if sent == &#34;&#34;:
                split_text.remove(sent)
            if &#34;  &#34; in sent:
                split_text.remove(sent)
            if sent.endswith(&#34; on&#34;) and (&#34;conference&#34; in sent.lower() or &#34;workshop&#34; in sent.lower() or
                                         &#34;international&#34; in sent.lower() or &#34;symposium&#34; in sent.lower()):
                full_name = (split_text[index] + &#34; &#34; + split_text[index + 1])
                return [full_name] + split_text
        return split_text</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cfp.Cfp.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the CFP object as a dictionary.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>A dictionary representing the CFP object.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dict(self):
    &#34;&#34;&#34;
    Returns the CFP object as a dictionary.
    Returns:
        dict: A dictionary representing the CFP object.
    &#34;&#34;&#34;
    return {&#39;name&#39;: self.name,
            &#39;start_date&#39;: self.start_date,
            &#39;end_date&#39;: self.end_date,
            &#39;location&#39;: self.location,
            &#39;submission_deadline&#39;: self.submission_deadline,
            &#39;notification_due&#39;: self.notification_due,
            &#39;final_version_deadline&#39;: self.final_version_deadline,
            &#39;url&#39;: self.url}</code></pre>
</details>
</dd>
<dt id="cfp.Cfp.extract_conference_name"><code class="name flex">
<span>def <span class="ident">extract_conference_name</span></span>(<span>self, conference_name_regex=re.compile('$^'), ordinal_regex=re.compile('$^'), conjunction_regex=re.compile('$^'), url_regex=re.compile('$^'))</span>
</code></dt>
<dd>
<section class="desc"><p>Function to extract the conference name from a CFP text. Uses rule-based patterns to assign scores to substrings
of the CFP's text, and returns the one with the highest score. Takes regex patterns containing key words to filter
by as parameters. By default, these regexes will match any string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conference_name_regex</code></strong></dt>
<dd>a regular expression matching key terms in a conference's name.
By default, it will match any string.</dd>
<dt><strong><code>ordinal_regex</code></strong></dt>
<dd>a regular expression matching ordinal numbers in a conference's name.
By default, it will match any string.</dd>
<dt><strong><code>conjunction_name_regex</code></strong></dt>
<dd>a regular expression matching terms signifying a conference is a joint conference.
By default, it will match any string.</dd>
<dt><strong><code>url_regex</code></strong></dt>
<dd>a regular expression matching URLs. By default, it will match any string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>The highest ranking string in the text.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_conference_name(self, conference_name_regex=re.compile(&#39;$^&#39;), ordinal_regex=re.compile(&#39;$^&#39;),
                            conjunction_regex=re.compile(&#39;$^&#39;), url_regex=re.compile(&#39;$^&#39;)):

    &#34;&#34;&#34;
    Function to extract the conference name from a CFP text. Uses rule-based patterns to assign scores to substrings
    of the CFP&#39;s text, and returns the one with the highest score. Takes regex patterns containing key words to filter
    by as parameters. By default, these regexes will match any string.

    Args:
        conference_name_regex: a regular expression matching key terms in a conference&#39;s name.
                               By default, it will match any string.
        ordinal_regex: a regular expression matching ordinal numbers in a conference&#39;s name.
                       By default, it will match any string.
        conjunction_name_regex: a regular expression matching terms signifying a conference is a joint conference.
                                By default, it will match any string.
        url_regex: a regular expression matching URLs. By default, it will match any string.

    Returns:
        str: The highest ranking string in the text.
    &#34;&#34;&#34;
    # a dictionary of form (sentence -&gt; score)
    candidate_names = {}
    split_cfp_text = self.preprocess_text()
    counter = 0

    for sent in split_cfp_text:
        score = 0
        if len(sent.split()) &lt; 4 or len(sent.split()) &gt; 20:
            score -= 50
        if counter &lt; 5:
            counter += 10 - (2 * counter)
        for word in sent.split():
            if conference_name_regex.search(word):
                score += 8
            if ordinal_regex.search(word) and counter &lt; 10:
                score += 10
            if conjunction_regex.search(word):
                score -= 5
            if url_regex.search(word):
                score -= 5

        candidate_names[sent] = score
        counter += 1

    print(candidate_names)
    # return the sentence with the highest score
    highest_score = (max(candidate_names, key=candidate_names.get))
    return highest_score</code></pre>
</details>
</dd>
<dt id="cfp.Cfp.extract_dates"><code class="name flex">
<span>def <span class="ident">extract_dates</span></span>(<span>self, nlp)</span>
</code></dt>
<dd>
<section class="desc"><p>Function which extracts mentions of dates from the CFP's text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nlp</code></strong></dt>
<dd>An instance of a Spacy NLP object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>A dictionary of form {date -&gt; sentence containing that date}.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_dates(self, nlp):
    &#34;&#34;&#34;
    Function which extracts mentions of dates from the CFP&#39;s text.

    Args:
        nlp: An instance of a Spacy NLP object.
    Returns:
        dict: A dictionary of form {date -&gt; sentence containing that date}.
    &#34;&#34;&#34;
    # a dictionary mapping a date to the sentence it is in
    date_to_sentence = {}
    # returns a list of sentences, split on line breaks.
    split_cfp_text = self.cfp_text.splitlines()

    for sent in split_cfp_text:
        doc = nlp(sent)

        # for each sentence in the cfp, NER tag it.
        # if there is a data in the sentence, store the data and the sentence it is contained in,
        # and map date -&gt; sentence.

        for entity in doc.ents:
            if entity.label_ == &#34;DATE&#34; and len(entity.text) &gt;= 10:
                date = entity.text
                date_to_sentence[date] = sent

    # removes any dates that cannot be parsed, i.e are incomplete, and makes sentence lowercase for next step
    date_to_sentence = {date: sent.lower() for date, sent in date_to_sentence.items() if
                        dateparser.parse(date) is not None}
    # returns a dictionary of form (date -&gt; sentence)
    return date_to_sentence</code></pre>
</details>
</dd>
<dt id="cfp.Cfp.extract_locations"><code class="name flex">
<span>def <span class="ident">extract_locations</span></span>(<span>self, nlp)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts all locations mentioned in the CFP's text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nlp</code></strong></dt>
<dd>An instance of a Spacy NLP object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>A list of all locations mentioned in the CFP's text.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_locations(self, nlp):
    &#34;&#34;&#34;
    Extracts all locations mentioned in the CFP&#39;s text.

    Args:
        nlp: An instance of a Spacy NLP object.
    Returns:
        list: A list of all locations mentioned in the CFP&#39;s text.
    &#34;&#34;&#34;
    doc = nlp(self.cfp_text)

    # Initialise lists for the locations within a given CFP
    cfp_locations = []

    for entity in doc.ents:
        if entity.label_ == &#34;GPE&#34;:
            cfp_locations.append(entity.text)

    return cfp_locations</code></pre>
</details>
</dd>
<dt id="cfp.Cfp.extract_urls"><code class="name flex">
<span>def <span class="ident">extract_urls</span></span>(<span>self, web_url_regex=re.compile('$^'))</span>
</code></dt>
<dd>
<section class="desc"><p>Method to extract any URLs from a CFP's text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>web_url_regex</code></strong></dt>
<dd>a regular expression matching URLs. By default, it will match any string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>A list of all mentions of URLs in the CFP's text.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_urls(self, web_url_regex=re.compile(&#39;$^&#39;)):
    &#34;&#34;&#34;
    Method to extract any URLs from a CFP&#39;s text.

    Args:
        web_url_regex: a regular expression matching URLs. By default, it will match any string.
    Returns:
        list: A list of all mentions of URLs in the CFP&#39;s text.
    &#34;&#34;&#34;
    urls = []
    split_cfp_text = self.preprocess_text()
    for sent in split_cfp_text:
        if web_url_regex.search(sent):
            urls.append(web_url_regex.search(sent).group(0))
    return urls</code></pre>
</details>
</dd>
<dt id="cfp.Cfp.preprocess_text"><code class="name flex">
<span>def <span class="ident">preprocess_text</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Method to preprocess text for information extraction. Text is split on newlines and commas,
and any conference names split over 2 lines are merged into one.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>a list of preprocessed sentences.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_text(self):
    &#34;&#34;&#34;
    Method to preprocess text for information extraction. Text is split on newlines and commas,
    and any conference names split over 2 lines are merged into one.

    Returns:
        list: a list of preprocessed sentences.
    &#34;&#34;&#34;
    text = self.cfp_text.replace(&#34;\n&#34;, &#34;,&#34;)
    split_text = text.split(&#34;,&#34;)
    split_text = [sent for sent in split_text if sent is not &#34;&#34;]
    for index, sent in enumerate(split_text):
        if sent == &#34;&#34;:
            split_text.remove(sent)
        if &#34;  &#34; in sent:
            split_text.remove(sent)
        if sent.endswith(&#34; on&#34;) and (&#34;conference&#34; in sent.lower() or &#34;workshop&#34; in sent.lower() or
                                     &#34;international&#34; in sent.lower() or &#34;symposium&#34; in sent.lower()):
            full_name = (split_text[index] + &#34; &#34; + split_text[index + 1])
            return [full_name] + split_text
    return split_text</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cfp.Cfp" href="#cfp.Cfp">Cfp</a></code></h4>
<ul class="">
<li><code><a title="cfp.Cfp.as_dict" href="#cfp.Cfp.as_dict">as_dict</a></code></li>
<li><code><a title="cfp.Cfp.extract_conference_name" href="#cfp.Cfp.extract_conference_name">extract_conference_name</a></code></li>
<li><code><a title="cfp.Cfp.extract_dates" href="#cfp.Cfp.extract_dates">extract_dates</a></code></li>
<li><code><a title="cfp.Cfp.extract_locations" href="#cfp.Cfp.extract_locations">extract_locations</a></code></li>
<li><code><a title="cfp.Cfp.extract_urls" href="#cfp.Cfp.extract_urls">extract_urls</a></code></li>
<li><code><a title="cfp.Cfp.preprocess_text" href="#cfp.Cfp.preprocess_text">preprocess_text</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>